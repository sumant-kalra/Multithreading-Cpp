[0]
[C++ Things]
    1. Most Vexing Parse
    2. Resource Acquisition Is Initialization (RAII)
    3. Lazy Initialization: Initialization upon first use
    4. Fine-grained lock & Coarse-grained lock; Appropriate Grain Size 

[1] 
[Fundamentals of Multithreading]
    Threads and processes as OS level concepts.
    Multithreading: Concurrent tasks of a process run as separate threads in OS.

[2] 
[Multithreading in C++ using <thread> library]

 Example Program: "Implement a thread safe class for printing in a file"
1. Creation of a child thread:
    (a) Construct thread class object with the parameterized constructor. 
        [Thread execution starts with the constructor call; Use Diagrams for visualization]
    (b) The thread must be joined or detached with the parent thread, before it is destroyed.

2. Thread Safe Code: 
    The program behaves in a specified way irrespective of the number of threads executing simultaneously.
    
    (a) No Race Conditions
        
        1. Mutex locks [No Copy; No move]
            - MUtually EXclusive flag, which once locked can not be locked by any other thread until it is unlocked.
            - Used to synchronize the threads access to the shared resources.
            - lock() and unlock()

            a. lock_gaurd [No Copy; No move]
                - wrapper class over mutex objects
                - Locks the mutex at the time of its construction and Unlocks the mutex at the time of destruction [RAII]
                - Preferred over raw mutex objects
            b. unique_lock [No Copy; Move - the underlying mutex]
                - wrapper class over mutex objects
                - provides flexibilty in locking and unlocking the mutex using explicit lock() and unlock() calls
                - Performance overhead
                - Preferred when implementing fine-locking granularity
        
        2. std::once_flag object and std::call_once() method
                - std::once_flag object: used in place of mutex objects for the situations when a certain piece of code (callable) 
                                         needs to be executed only once throughout the execution of the multithreaded application.
                - std::call_once() method: takes the std::once_flag object and the callable as arguments.
                                           The callable is executed only once by the first thread by std::call_once() method.
                Improves the performance by eliminating the redundant executions, which could have been made if it is not used.
        
        3. Never leak a handle of the data to the outside.
            - Never return it as a reference from the function.
            - Never pass it as a reference to a user defined function.
        
        4. Design the interfaces properly.
            - Donot unlock the resource when the thread is still processing the data.

    (b) No Deadlocks

        1. Prefer locking a single mutex at a time.
        2. Avoid locking a mutex and then calling a user defined function.
        3. Use std::lock() to lock more than one mutex, and ask lock_guard to adopt to the lock.
            - Locks a number of mutexes specified as argument using some deadlock avoidance algorithms.
            - If std::lock() is used along with lock_guard then we need to tell lock_gaurd that the mutex is already locked, just 
              adopt the existing lock, that is unlock the lock once you (lock_guard) goes out of scope.
        4. Lock the mutexes in the same order for multiple threads if it is not possible to use std::lock()





